// Generated by CoffeeScript 1.4.0
var MailAccount, log, storage, verbose;

verbose = false;

log = function(text) {
  if (verbose) {
    return console.log(text);
  }
};

storage = chrome.extension.getBackgroundPage().storage;

MailAccount = function(settingsObj) {
  var NSResolver, abortTimerId, archiveAsRead, atomLabel, errorLives, getAt, getInboxCount, gmailAt, handleError, handleSuccess, inboxLabel, isStopped, mailAddress, mailArray, mailTitle, mailURL, newestMail, onGetInboxSuccess, openInTab, pollInterval, postAction, replyToCallback, requestTimeout, requestTimer, scheduleRequest, setLoggedOutState, that, unreadCount, updateUnreadCount;
  pollInterval = storage.get('gc_poll');
  requestTimeout = 10000;
  openInTab = storage.get('gc_open_tabs');
  archiveAsRead = storage.get('gc_archive_read');
  mailURL = "https://mail.google.com";
  if (settingsObj.domain != null) {
    mailURL += "/a/" + settingsObj.domain + "/";
  } else if (settingsObj.accountNr != null) {
    mailURL += "/mail/u/" + settingsObj.accountNr + "/";
  } else {
    mailURL += "/mail/";
  }
  inboxLabel = storage.get('gc_open_label');
  atomLabel = storage.get('gc_check_label');
  mailArray = [];
  newestMail = void 0;
  unreadCount = -1;
  mailTitle = void 0;
  mailAddress = void 0;
  abortTimerId = void 0;
  gmailAt = null;
  errorLives = 5;
  isStopped = false;
  requestTimer = void 0;
  this.onUpdate;
  this.onError;
  this.isDefault;
  that = this;
  onGetInboxSuccess = function(data, callback) {
    var foundNewMail, fullCount, newMail, newMailArray, parser, xmlDocument, _i, _len;
    foundNewMail = false;
    parser = new DOMParser();
    xmlDocument = $(parser.parseFromString(data, "text/xml"));
    fullCount = xmlDocument.find("fullcount").text();
    mailTitle = $(xmlDocument.find("title")[0]).text().replace("Gmail - ", "");
    mailAddress = mailTitle.match(/([\S]+@[\S]+)/g)[0];
    newMailArray = [];
    if (fullCount < unreadCount || unreadCount === -1) {
      foundNewMail = true;
      mailArray = [];
    }
    xmlDocument.find("entry").each(function() {
      var authorMail, authorName, id, isNewMail, issued, link, mailObject, oldMail, shortTitle, summary, title, _i, _len;
      title = $(this).find("title").text();
      shortTitle = title;
      summary = $(this).find("summary").text();
      issued = (new Date()).setISO8601($(this).find("issued").text());
      link = $(this).find("link").attr("href");
      id = link.replace(/.*message_id=(\d\w*).*/, "$1");
      authorName = $(this).find("author").find("name").text();
      authorMail = $(this).find("author").find("email").text();
      if (!(authorName != null) || authorName.length < 1) {
        authorName = "(unknown sender)";
      }
      if (!(title != null) || title.length < 1) {
        shortTitle = title = "(No subject)";
      } else {
        if (title.length > 63) {
          shortTitle = title.substr(0, 60) + "...";
        }
      }
      title = Encoder.XSSEncode(title, true);
      shortTitle = Encoder.XSSEncode(shortTitle, true);
      summary = Encoder.XSSEncode(summary, true);
      authorMail = Encoder.XSSEncode(authorMail, true);
      authorName = Encoder.XSSEncode(authorName, true);
      mailObject = {
        id: id,
        title: title,
        shortTitle: shortTitle,
        summary: summary,
        link: link,
        issued: issued,
        authorName: authorName,
        authorMail: authorMail
      };
      isNewMail = true;
      for (_i = 0, _len = mailArray.length; _i < _len; _i++) {
        oldMail = mailArray[_i];
        if (oldMail.id === mailObject.id) {
          isNewMail = false;
        }
      }
      if (isNewMail) {
        foundNewMail = true;
        return newMailArray.push(mailObject);
      }
    });
    newMailArray.sort(function(a, b) {
      if (a.issued > b.issued) {
        return -1;
      }
      if (a.issued < b.issued) {
        return 1;
      }
      return 0;
    });
    if (newMailArray.length > 0) {
      newestMail = newMailArray[0];
    }
    for (_i = 0, _len = newMailArray.length; _i < _len; _i++) {
      newMail = newMailArray[_i];
      mailArray.push(newMail);
    }
    mailArray.sort(function(a, b) {
      if (a.issued > b.issued) {
        return -1;
      }
      if (a.issued < b.issued) {
        return 1;
      }
      return 0;
    });
    if (foundNewMail) {
      handleSuccess(fullCount);
    } else {
      log(mailURL + "feed/atom/" + atomLabel + " - No new mail found.");
    }
    if (callback != null) {
      return window.setTimeout(callback, 0);
    }
  };
  handleSuccess = function(count) {
    log("success!");
    window.clearTimeout(abortTimerId);
    errorLives = 5;
    return updateUnreadCount(count);
  };
  handleError = function(xhr, text, err) {
    log("error! " + xhr + " " + text + " " + err);
    window.clearTimeout(abortTimerId);
    if (errorLives > 0) {
      errorLives--;
    }
    if (errorLives === 0) {
      errorLives = -1;
      return setLoggedOutState();
    }
  };
  getInboxCount = function(callback) {
    try {
      log("requesting " + mailURL + "feed/atom/" + atomLabel);
      $.ajax({
        type: "GET",
        dataType: "text",
        url: mailURL + "feed/atom/" + atomLabel,
        timeout: requestTimeout,
        success: function(data) {
          return onGetInboxSuccess(data, callback);
        },
        error: function(xhr, status, err) {
          return handleError(xhr, status, err);
        }
      });
      if (gmailAt == null) {
        return getAt();
      }
    } catch (err) {
      console.error("exception: " + err);
      return handleError();
    }
  };
  scheduleRequest = function(interval) {
    if (isStopped) {
      return;
    }
    log("scheduling new request");
    if (interval != null) {
      return window.setTimeout(getInboxCount, interval);
    } else {
      requestTimer = window.setTimeout(getInboxCount, pollInterval);
      return window.setTimeout(scheduleRequest, pollInterval);
    }
  };
  updateUnreadCount = function(count) {
    if (unreadCount !== count) {
      unreadCount = count;
      log("unread count: " + unreadCount);
      if (that.onUpdate != null) {
        try {
          log("trying to call onUpdate...");
          return that.onUpdate(that);
        } catch (e) {
          return console.error(e);
        }
      }
    }
  };
  setLoggedOutState = function() {
    if (that.onError != null) {
      try {
        log("trying to call onError...");
        that.onError(that);
      } catch (e) {
        console.error(e);
      }
    }
    unreadCount = -1;
    return mailArray = new Array();
  };
  postAction = function(postObj) {
    var action, postParams, postURL, postXHR, threadid;
    if (!(gmailAt != null)) {
      return getAt(postAction, postObj);
    } else {
      threadid = postObj.threadid;
      action = postObj.action;
      postURL = mailURL.replace("http:", "https:");
      postURL += "h/" + Math.ceil(1000000 * Math.random()) + "/";
      postParams = "t=" + threadid + "&at=" + gmailAt + "&act=" + action;
      log(postURL);
      log(postParams);
      postXHR = new XMLHttpRequest();
      postXHR.onreadystatechange = function() {
        if (this.readyState === 4 && this.status === 200) {
          return window.setTimeout(getInboxCount, 0);
        } else {
          return this.readyState === 4 && this.status === 401;
        }
      };
      postXHR.onerror = function(error) {
        return log("mark as read error: " + error);
      };
      postXHR.open("POST", postURL, true);
      postXHR.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
      return postXHR.send(postParams);
    }
  };
  getAt = function(callback, tag) {
    var gat_xhr, getURL;
    getURL = mailURL + "h/" + Math.ceil(1000000 * Math.random()) + "/?ui=html&zy=c";
    gat_xhr = new XMLHttpRequest();
    gat_xhr.onreadystatechange = function() {
      var matches;
      if (this.readyState === 4 && this.status === 200) {
        log(this.responseText);
        matches = this.responseText.match(/\at=([^"]+)/);
        log(matches);
        if ((matches != null) && matches.length > 0) {
          gmailAt = matches[1];
          log(gmailAt);
          if (callback != null) {
            return callback(tag);
          }
        }
      } else {
        return this.readyState === 4 && this.status === 401;
      }
    };
    gat_xhr.onerror = function(error) {
      return log("get gmail_at error: " + error);
    };
    gat_xhr.open("GET", getURL, true);
    return gat_xhr.send(null);
  };
  this.startScheduler = function() {
    log("starting scheduler...");
    getInboxCount();
    return scheduleRequest();
  };
  this.stopScheduler = function() {
    log("stopping scheduler...");
    isStopped = true;
    if (requestTimer != null) {
      return window.clearTimeout(requestTimer);
    }
  };
  this.openInbox = function() {
    log("Opening inbox");
    return chrome.windows.getAll({
      populate: true
    }, function(windows) {
      var i, tab, w;
      for (w in windows) {
        for (i in windows[w].tabs) {
          tab = windows[w].tabs[i];
          if (tab.url.indexOf(mailURL) >= 0) {
            chrome.tabs.update(tab.id, {
              selected: true
            });
            return;
          } else if (tab.url.indexOf(mailURL.replace("http:", "https:")) >= 0) {
            chrome.tabs.update(tab.id, {
              selected: true
            });
            return;
          } else if (tab.url.indexOf(mailURL.replace("https:", "http:")) >= 0) {
            chrome.tabs.update(tab.id, {
              selected: true
            });
            return;
          }
        }
      }
      return chrome.tabs.create({
        url: mailURL + inboxLabel
      });
    });
  };
  this.openThread = function(threadid) {
    if (threadid != null) {
      chrome.tabs.create({
        url: mailURL + inboxLabel + "/" + threadid
      });
      postAction({
        threadid: threadid,
        action: "rd"
      });
      return scheduleRequest(1000);
    }
  };
  this.getThread = function(accountid, threadid, callback) {
    var getURL, gt_xhr;
    console.log('getThread');
    if (threadid != null) {
      getURL = mailURL.replace("http:", "https:") + "h/" + Math.ceil(1000000 * Math.random()) + "/?v=pt&th=" + threadid;
      gt_xhr = new XMLHttpRequest();
      gt_xhr.onreadystatechange = function() {
        var $body, $responseWrapper, $tables;
        if (this.readyState === 4 && this.status === 200) {
          $body = $("<div class='fullEmailBody'/>");
          $responseWrapper = $("<div id='$responseWrapper'/>");
          $responseWrapper = $("<div id='$responseWrapper'>" + this.responseText + "</div>");
          $tables = void 0;
          $tables = $responseWrapper.find("> table");
          if ($tables.length) {
            $tables = $tables.splice(0, 1);
          } else {
            $tables = $responseWrapper.find(".maincontent .message");
          }
          if ($tables.length && $tables.each) {
            $tables.each(function(i) {
              var $messageNode, $table, $td, $threadNode, threadText;
              $messageNode = $(this);
              $messageNode.find("> tbody > tr:last-child").addClass("threadBody");
              $table = $("<table width='100%' class='thread'/>");
              $table.append($("<tr><td style='padding:0'></td></tr>"));
              $table.find("td").append($messageNode);
              $threadNode = $messageNode.find("tr:eq(2)");
              threadText = $threadNode.text();
              threadText = threadText.replace(/\[Quoted text hidden\]/g, "");
              threadText = threadText.replace("[Texte des messages précédents masqué]", "");
              $messageNode.find("tr:eq(0), tr:eq(1)").hide();
              $td = $("<td colspan=10 class='fullEmailSenderArea'/>");
              return $body.append($table);
            });
          } else {
            console.warn("Could not parse body from print page: ", $responseWrapper);
          }
          callback(accountid, threadid, $body);
          return console.log($body);
        } else {
          return this.readyState === 4 && this.status === 401;
        }
      };
      gt_xhr.onerror = function(error) {
        return log("get thread error: " + error);
      };
      gt_xhr.open("GET", getURL, true);
      return gt_xhr.send(null);
    }
  };
  this.replyToThread = function(replyObj) {
    var callback, postParams, postURL, postXHR, reply, threadid;
    if (gmailAt == null) {
      return getAt(that.replyToThread, replyObj);
    } else {
      threadid = replyObj.id;
      reply = escape(replyObj.body);
      callback = replyObj.callback;
      postURL = mailURL + "h/" + Math.ceil(1000000 * Math.random()) + "/" + "?v=b&qrt=n&fv=cv&rm=12553ee9085c11ca&at=xn3j33xxbkqkoyej1zgstnt6zkxb1c&pv=cv&th=12553ee9085c11ca&cs=qfnq";
      postParams = "body=" + reply;
      log(postParams);
      postXHR = new XMLHttpRequest();
      postXHR.onreadystatechange = function() {
        if (this.readyState === 4 && this.status === 200) {

        } else {
          return this.readyState === 4 && this.status === 401;
        }
      };
      postXHR.onerror = function(error) {
        return log("reply to thread error: " + error);
      };
      postXHR.open("POST", postURL, true);
      postXHR.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
      return postXHR.send(postParams);
    }
  };
  this.readThread = function(threadid) {
    if (threadid != null) {
      return postAction({
        threadid: threadid,
        action: "rd"
      });
    }
  };
  this.unreadThread = function(threadid) {
    if (threadid != null) {
      return postAction({
        threadid: threadid,
        action: "ur"
      });
    }
  };
  this.archiveThread = function(threadid) {
    if (threadid != null) {
      postAction({
        threadid: threadid,
        action: "arch"
      });
      if (archiveAsRead) {
        return postAction({
          threadid: threadid,
          action: "rd"
        });
      }
    }
  };
  this.deleteThread = function(threadid) {
    if (threadid != null) {
      postAction({
        threadid: threadid,
        action: "rd"
      });
      return postAction({
        threadid: threadid,
        action: "tr"
      });
    }
  };
  this.spamThread = function(threadid) {
    if (threadid != null) {
      return postAction({
        threadid: threadid,
        action: "sp"
      });
    }
  };
  this.starThread = function(threadid) {
    if (threadid != null) {
      return postAction({
        threadid: threadid,
        action: "st"
      });
    }
  };
  this.getUnreadCount = function() {
    return Number(unreadCount);
  };
  this.getInboxLink = function() {
    if ((mailTitle != null) && mailTitle !== "") {
      return mailTitle;
    }
    return mailURL;
  };
  this.getAddress = function() {
    if ((mailAddress != null) && mailAddress !== "") {
      return mailAddress;
    }
    return "(unknown account)";
  };
  this.getMail = function() {
    return mailArray;
  };
  this.getNewestMail = function() {
    return newestMail;
  };
  this.openNewestMail = function() {
    if (newestMail != null) {
      return that.openThread(newestMail.id);
    }
  };
  this.readNewestMail = function() {
    if (newestMail != null) {
      return that.readThread(newestMail.id);
    }
  };
  this.spamNewestMail = function() {
    if (newestMail != null) {
      return that.spamThread(newestMail.id);
    }
  };
  this.deleteNewestMail = function() {
    if (newestMail != null) {
      return that.deleteThread(newestMail.id);
    }
  };
  this.archiveNewestMail = function() {
    if (newestMail != null) {
      return that.archiveThread(newestMail.id);
    }
  };
  this.starNewestMail = function() {
    if (newestMail != null) {
      return that.starThread(newestMail.id);
    }
  };
  this.getURL = function() {
    return mailURL;
  };
  this.getNewAt = function() {
    return getAt();
  };
  this.refreshInbox = function(callback) {
    return getInboxCount(callback);
  };
  this.composeNew = function() {
    if (openInTab) {
      return chrome.tabs.create({
        url: mailURL + "?view=cm&fs=1&tf=1"
      });
    } else {
      return window.open(mailURL + "?view=cm&fs=1&tf=1", "Compose new message", "width=640,height=480");
    }
  };
  this.sendPage = function(tab) {
    var body, subject, urlToOpen;
    body = encodeURIComponent(unescape(tab.url));
    subject = encodeURIComponent(unescape(tab.title));
    subject = subject.replace("%AB", "%2D");
    urlToOpen = mailURL + "?view=cm&fs=1&tf=1" + "&su=" + subject + "&body=" + body;
    if (openInTab) {
      return chrome.tabs.create({
        url: urlToOpen
      });
    } else {
      return window.open(urlToOpen, "Compose new message", "width=640,height=480");
    }
  };
  this.replyTo = function(mail) {
    var issued, replyURL, subject, threadbody, to;
    to = encodeURIComponent(mail.authorMail);
    subject = Encoder.htmlDecode(mail.title);
    subject = (subject.search(/^Re: /i) > -1 ? subject : "Re: " + subject);
    subject = encodeURIComponent(subject);
    issued = mail.issued;
    threadbody = "\r\n\r\n" + issued.toString() + " <" + mail.authorMail + ">:\r\n" + Encoder.htmlDecode(mail.summary);
    threadbody = encodeURIComponent(threadbody);
    replyURL = mailURL.replace("http:", "https:") + "?view=cm&tf=1&to=" + to + "&su=" + subject + "&body=" + threadbody;
    log(replyURL);
    if (openInTab) {
      return chrome.tabs.create({
        url: replyURL
      });
    } else {
      return window.open(replyURL, "Compose new message", "width=640,height=480");
    }
  };
  replyToCallback = function(threadid, threadbody) {
    var i, mail, replyURL, subject, to;
    mail = void 0;
    for (i in mailArray) {
      if (mailArray[i].id === threadid) {
        mail = mailArray[i];
        break;
      }
    }
    if (mail == null) {
      return;
    }
    to = encodeURIComponent(mail.authorMail);
    subject = mail.title;
    subject = (subject.search(/^Re: /i) > -1 ? subject : "Re: " + subject);
    subject = encodeURIComponent(subject);
    threadbody = encodeURIComponent(threadbody);
    replyURL = mailURL + "?view=cm&fs=1&tf=1&to=" + to + "&su=" + subject + "&body=" + mail.summary;
    if (openInTab) {
      return chrome.tabs.create({
        url: replyURL
      });
    } else {
      return window.open(replyURL, "Compose new message", "width=640,height=480");
    }
  };
  NSResolver = function(prefix) {
    if (prefix === "gmail") {
      return "http://purl.org/atom/ns#";
    }
  };
  return chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
    if (changeInfo.status === "loading" && (tab.url.indexOf(mailURL) === 0 || tab.url.indexOf(mailURL.replace("http:", "https:")) === 0 || tab.url.indexOf(mailURL.replace("https:", "http:")) === 0)) {
      log("saw gmail! updating...");
      return window.setTimeout(getInboxCount, 0);
    }
  });
};
