:set -XNoMonomorphismRestriction
:set -fglasgow-exts

import Control.Applicative
import Control.Monad
import Control.Concurrent
import Control.Concurrent.Async
import Control.Parallel

import Data.String
import Data.Char
import Data.List
import Data.Monoid
import Control.Monad.IO.Class

import qualified IPPrint
import qualified Language.Haskell.HsColour as HsColour
import qualified Language.Haskell.HsColour.Colourise as HsColour
import qualified Language.Haskell.HsColour.Output as HsColour

let myColourPrefs = HsColour.defaultColourPrefs { HsColour.conid = [HsColour.Foreground HsColour.Yellow, HsColour.Bold], HsColour.conop = [HsColour.Foreground HsColour.Yellow], HsColour.string = [HsColour.Foreground HsColour.Green], HsColour.char = [HsColour.Foreground HsColour.Red], HsColour.number = [HsColour.Foreground HsColour.Cyan, HsColour.Bold], HsColour.layout = [HsColour.Foreground HsColour.White], HsColour.keyglyph = [HsColour.Foreground HsColour.White] }

let myPrint = putStrLn . HsColour.hscolour (HsColour.TTYg HsColour.XTerm256Compatible) myColourPrefs False False "" False . IPPrint.pshow

:{
let myPrint2 x = do
        prefs <- readColourPrefs
        let colour = hscolour tty prefs False False "<interactive>" False
        putStrLn . colour. groom $ x
      where
        readColourPrefs = Language.Haskell.HsColour.Colourise.readColourPrefs
        hscolour = Language.Haskell.HsColour.hscolour
        tty = Language.Haskell.HsColour.TTY
        groom = Text.Groom.groom
:}

:set -interactive-print=myPrint

:set prompt "Î» "
:set editor vim
:! clear
